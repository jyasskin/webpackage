<pre class='metadata'>
Title: Loading Web Packages
Shortname: web-package-loading
Level: none
Status: ED
Group: WICG
Repository: WICG/webpackage
URL: https://wicg.github.io/webpackage/loading.html
Editor: Jeffrey Yasskin, Google Inc. https://google.com/, jyasskin@chromium.org, w3cid 72192
Abstract: How UAs load web packages: signed exchanges and bundles.

Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: markdown yes, css no
Assume Explicit For: yes
</pre>
<pre class='biblio'>
{
    "draft-ietf-httpbis-variants": {
        "authors": [
            "Mark Nottingham"
        ],
        "href": "https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html",
        "title": "HTTP Representation Variants",
        "status": "WD",
        "publisher": "IETF"
    },
    "draft-thomson-http-mice": {
        "authors": [
            "Martin Thomson"
        ],
        "href": "https://tools.ietf.org/html/draft-thomson-http-mice-03",
        "title": "Merkle Integrity Content Encoding",
        "status": "ED",
        "publisher": "IETF"
    },
    "draft-yasskin-http-origin-signed-responses": {
        "authors": [
            "Jeffrey Yasskin"
        ],
        "href": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html",
        "title": "Signed HTTP Exchanges",
        "status": "ED",
        "publisher": "IETF"
    },
    "draft-yasskin-httpbis-origin-signed-exchanges-impl-02": {
        "authors": [
            "Jeffrey Yasskin",
            "Kouhei Ueno"
        ],
        "href": "https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02",
        "title": "Signed HTTP Exchanges Implementation Checkpoints",
        "status": "ED",
        "publisher": "IETF"
    },
    "draft-yasskin-httpbis-origin-signed-exchanges-impl-03": {
        "authors": [
            "Jeffrey Yasskin",
            "Kouhei Ueno"
        ],
        "href": "https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-03",
        "title": "Signed HTTP Exchanges Implementation Checkpoints",
        "status": "ED",
        "publisher": "IETF"
    },
    "draft-yasskin-wpack-bundled-exchanges": {
        "authors": [
            "Jeffrey Yasskin"
        ],
        "href": "https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html",
        "title": "Bundled HTTP Exchanges",
        "status": "ED",
        "publisher": "IETF"
    },
    "http-dig-alg": {
        "href": "https://www.iana.org/assignments/http-dig-alg/http-dig-alg.xhtml",
        "title": "Hypertext Transfer Protocol (HTTP) Digest Algorithm Values",
        "status": "LS",
        "publisher": "IANA"
    },
    "RFC8446": {
        "authors": [
            "E. Rescorla"
        ],
        "href": "https://tools.ietf.org/html/draft-ietf-tls-tls13",
        "title": "The Transport Layer Security (TLS) Protocol Version 1.3",
        "status": "WD",
        "publisher": "IETF"
    },
    "SHA2": {
        "href": "http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf",
        "title": "FIPS PUB 180-4, Secure Hash Standard"
    }
}
</pre>
<pre class='anchors'>
spec: RFC3230; urlPrefix: https://tools.ietf.org/html/rfc3230#
    type: http-header
        text: Digest; url: section-4.3.2
spec: RFC5280; urlPrefix: https://tools.ietf.org/html/rfc5280#
    type: dfn
        text: AlgorithmIdentifier; url: section-4.1.1.2
        text: Subject Public Key Info; url: section-4.1.2.7
        text: Certificate Extensions; url: section-4.2
spec: RFC5480; urlPrefix: https://tools.ietf.org/html/rfc5480#
    type: dfn
        text: id-ecPublicKey; url: section-2.1.1
        text: secp256r1; url: section-2.1.1.1
spec: RFC6960; urlPrefix: https://tools.ietf.org/html/rfc6960#
    text: OCSPResponse; type: dfn; url: section-4.2.1
spec: RFC6962; urlPrefix: https://tools.ietf.org/html/rfc6962#
    text: SignedCertificateTimestampList; type: dfn; url: section-3.3
spec: RFC7230; urlPrefix: https://tools.ietf.org/html/rfc7230#
    type: dfn
        text: field-name; url: section-3.2
        text: field-value; url: section-3.2
spec: RFC7231; urlPrefix: https://tools.ietf.org/html/rfc7231#
    type: dfn
        text: HTTP media type; url: section-3.1.1.1
    type: http-header
        text: Date; url: section-7.1.1.2
spec: RFC8446; urlPrefix: https://tools.ietf.org/html/draft-ietf-tls-tls13-28#
    text: ecdsa_secp256r1_sha256; type: dfn; url: section-4.2.3
spec: draft-ietf-httpbis-variants; urlPrefix: https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#
    type: dfn
        text: Variants cache behavior; url: cache
    type: http-header
        text: Variant-Key; url: variant-key
        text: Variants; url: variants
spec: draft-thomson-http-mice; urlPrefix: https://tools.ietf.org/html/draft-thomson-http-mice-03#
    type: dfn
        text: mi-sha256 parameter; url: section-3.1
        text: integrity proof for the first record; url: section-2.2
spec: draft-yasskin-wpack-bundled-exchanges; urlPrefix: https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#
    type: dfn
        text: loading a bundle's metadata; url: semantics-load-metadata
        text: parsing a CBOR item; url: parse-known-length
        text: signed-subset rule; url: signatures-section
        for: bundle
            text: index section; url: index-section
spec: draft-yasskin-http-origin-signed-responses; urlPrefix: https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#
    type: dfn
        text: off-path attackers; url: seccons-off-path
        text: uncached response header; url: uncached-headers
spec: draft-yasskin-httpbis-origin-signed-exchanges-impl-02; urlPrefix: https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02#
    type: dfn
        text: canonically-encoded CBOR; url: section-3.4
        text: CanSignHttpExchanges; url: section-4.2
        text: cert-chain CDDL; url: section-3.3
spec: draft-ietf-httpbis-header-structure; urlPrefix: https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07#
    text: Parsing HTTP1 Header Fields into Structured Headers; type: dfn; url: section-4.2
spec: http-dig-alg; urlPrefix: https://www.iana.org/assignments/http-dig-alg/http-dig-alg.xhtml#
    type: dfn; text: Digest algorithm; url: http-dig-alg-1
spec: network-error-logging; urlPrefix: https://w3c.github.io/network-error-logging/#
    type: dfn
        for: network error
            text: type; url: dfn-types
spec: SHA2; urlPrefix: http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
    type: dfn
        text: SHA-256; url: #
</pre>
<pre class='link-defaults'>
spec:fetch; type:dfn; for:/; text:response
spec:streams; type:interface; text:ReadableStream
</pre>

<section class="non-normative">

# Introduction # {#intro}

<em>This section is non-normative.</em>

The Signed Exchanges specification
[[draft-yasskin-http-origin-signed-responses]] describes a way to provide one or
more signatures for an HTTP exchange and to check whether any of those
signatures is trusted as authoritative for a particular origin. This
specification describes how web browsers load those exchanges. It is expressed
as several monkeypatches to the [[FETCH]] specification which call algorithms
defined here.

## Overview ## {#overview}

When fetching a resource (`https://distributor.example.org/foo.sxg`) with the
`application/signed-exchange` [=MIME type=], the UA parses it, checks its
signatures, and then if all is well, redirects to its request URL
(`https://publisher.example.org/foo`) with a "stashed" exchange attached to the
request. The redirect applies all the usual processing, and then when it would
normally check for an HTTP cache hit, it also checks whether the stashed request
matches the redirected request and which of the stashed exchange or HTTP cache
contents is newer. If the stashed exchange matches and is newer, the UA returns
the stashed response.

A Service Worker for `https://distributor.example.org/` gets to handle the
original request. A Service Worker for `https://publisher.example.org/` can then
handle the redirect. If it needs to know that signed exchange content is
available for the request it's handling, it has two options:

1. If {{ServiceWorkerRegistration/navigationPreload}} is enabled, the signed
    response will be available in the {{FetchEvent}}'s
    {{FetchEvent/preloadResponse}}. Note that this will also cause a network
    request for requests that aren't served from a signed exchange.
1. {{Request/clone()}} the {{FetchEvent/request}} and set its {{Request/cache}}
    to {{RequestCache/"only-if-cached"}}, to retrieve the matching response from
    either the signed exchange or the HTTP cache. Note that
    {{WindowOrWorkerGlobalScope/fetch()}}ing a *new* {{Request}} with the same
    {{Request/url}} will *not* retrieve the response from the signed exchange.

## Other interesting details ## {#details}

* Like with `<link rel="prefetch">` and `<link rel="preload">`, the UA will use
    the stashed response even if its HTTP cache headers have expired. This makes
    it easier to specify that the contents of the signed exchange don't wind up
    in the HTTP cache before our security reviewers have gotten comfortable with
    that idea. The publisher can still control resource expiration by setting
    the Signature header's [=exchange signature/expiration time=] to the cache
    expiration time if that's sooner than they'd otherwise have the signature
    expire.

</section>

# Fetch monkeypatches # {#monkeypatches}

When fetching a signed exchange, the UA needs to look for a trusted and valid
signature and then redirect to the contained resource. We don't put the
contained resource in the HTTP cache, so redirects get a new field to store it.

## A request's stashed exchange ## {#mp-request-stashed-exchange}

A [=request=] has an associated <dfn for="request">stashed exchange</dfn>, which
is null or an [=exchange=].

A [=request=] has an associated <dfn for="request">stashed bundle</dfn>, which
is null or a [=bundle=].

<h3 algorithm id="mp-request-clone">Request clone</h3>

Rewrite [=request/clone|clone a request=] to run these steps:

<ol>
 <li>Let |newRequest| be a copy of |request|, except for its
  [=request/body=]<ins>, [=request/stashed exchange=], and
  [=request/stashed bundle=]</ins>.

 <li>If |request|'s [=request/body=] is non-null, set |newRequest|'s
  [=request/body=] to the result of [=body/cloning=] |request|'s
  [=request/body=].

 <li><ins>If |request|'s [=request/stashed exchange=] is non-null, set
  |newRequest|'s [=request/stashed exchange=] to an exchange whose
  [=exchange/request URL=] is a copy of |request|'s [=request/stashed
  exchange=]'s [=exchange/request URL=] and whose [=exchange/response=] is the
  [=response/clone=] of |request|'s [=request/stashed exchange=]'s
  [=exchange/response=].</ins>

 <li>Return |newRequest|.
</ol>

<h3 algorithm id="mp-response-date">Response date</h3>

A [=response=] |response|'s <dfn for="response">date</dfn> is the result of:

1. Let |date| be the result of [=extracting header list values=] given `` `Date`
    `` and |response|'s [=response/header list=].
1. If |date| is a failure, return the point in time of the beginning of the
    universe.
1. Return the point in time represented by |date|, as interpreted for the <a
    http-header>Date</a> header field.

<h3 algorithm id="mp-http-fetch">Monkeypatch HTTP fetch</h3>

In [=HTTP fetch=], before

> 5. If |actualResponse|’s [=response/status=] is a [=redirect status=], then:
>     ...

add the following steps:

5. If the [=signed exchange version=] of |actualResponse| is:

    <dl class="switch">
    : undefined
    :: Do nothing.

    : `"b2"` or `"b3"`
    ::
        1. Let |report| be the result of [=create a new signed exchange report=]
            with |request| and |actualResponse|.
        1. Let |parsedExchange| be the result of [=parsing a signed
            exchange=] of version `b2` or `b3`, respectively, from
            |actualResponse| in the context of |request|'s [=request/client=],
            reporting to |report|.
        1. If |parsedExchange| is not an [=exchange=], run
            [=queue a signed exchange report=] |report| with
            |parsedExchange| as the result, and return a [=network error=].
        1. [=In parallel=], [=wait and queue a report for=] |parsedExchange| and
            |report|.
        1. Set |actualResponse|'s [=status=] to `303`.
        1. [=header list/Set=] |actualResponse|'s `` `Location` `` header to
            the [=ASCII encoding=] of the [=URL serializer|serialization=]
            of |parsedExchange|'s [=exchange/request URL=].
        1. Set |request|'s [=request/stashed exchange=] to |parsedExchange|.

    : Anything else
    ::
        1. Let |fallbackUrlBytes| be the result of [=extracting the sxg fallback
            URL=] from |actualResponse|.
        1. If |fallbackUrlBytes| is a failure, return a [=network error=].
        1. Set |actualResponse|'s [=status=] to `303`.
        1. [=header list/Set=] |actualResponse|'s `` `Location` `` header to
            |fallbackUrlBytes|.

    </dl>

    Note: The final [[draft-yasskin-http-origin-signed-responses]] will use a
    version of `` `1` ``, but this specification tracks what's actually
    implemented in browsers, which still uses draft versions.

6. If the [=bundle version=] of |actualResponse| is not undefined:

    1. Let |report| be the result of [=create a new bundle report=]
        with |request| and |actualResponse|.
    1. Let |parsedBundle| be the result of [=parsing a bundle=] from
        |actualResponse| in the context of |request|'s [=request/client=],
        reporting to |report|.
    1. If the [=bundle version=] of |actualResponse| is not `"b1"` but
        |parsedBundle| is a [=bundle=], set |parsedBundle| to a "version error"
        with a fallback URL of its [=bundle/manifest=]'s
        {{WebAppManifest/start_url}}.
    1. If |parsedBundle| is an error:
        1. Run [=queue a bundle report=] |report| with |parsedBundle| as the
            result.
        1. If |parsedBundle| isn't a "version error", return a [=network error=].
        1. Assert: |parsedBundle| has a fallback URL
        1. Let |fallbackUrl| be |parsedBundle|'s fallback URL.
        1. Set |actualResponse|'s [=status=] to `303`.
        1. [=header list/Set=] |actualResponse|'s `` `Location` `` header to the
            [=ASCII encoding=] of the [=URL serializer|serialization=] of
            |fallbackUrl|.

    1. Otherwise:
        1. [=In parallel=], [=wait and queue a bundle report for=] |parsedBundle| and
            |report|.
        1. Set |actualResponse|'s [=status=] to `303`.
        1. [=header list/Set=] |actualResponse|'s `` `Location` `` header to
            the [=ASCII encoding=] of the [=URL serializer|serialization=]
            of |parsedBundle|'s [=bundle/manifest=]'s {{WebAppManifest/start_url}}.
        1. Set |request|'s [=request/stashed bundle=] to |parsedBundle|.

    Note: The final [[draft-yasskin-wpack-bundled-exchanges]] will use a version
    of `` `1` ``, but this specification tracks what's actually implemented in
    browsers, which still uses draft versions.

<h3 algorithm id="mp-http-network-or-cache-fetch">Monkeypatch HTTP-network-or-cache fetch</h3>

In <a spec="fetch">HTTP-network-or-cache fetch</a>, after

> 5.19. If |httpRequest|’s [=request/cache mode=] is neither "`no-store`" nor
> "`reload`", then: ...

add the following steps:

20. If |httpRequest|'s [=request/stashed exchange=] isn't null:
    1. Let |stashedExchange| be |httpRequest|'s [=request/stashed exchange=].
    1. If
        * |httpRequest| [=matches the stored exchange=] |stashedExchange| and
        * |response| is null or |response|'s [=response/date=] is earlier than
            |httpRequest|'s [=request/stashed exchange=]'s
            [=exchange/response=]'s [=response/date=]

        then set |response| to |httpRequest|'s [=request/stashed exchange=]'s
        [=exchange/response=].
    1. If |response| is null and |httpRequest|'s [=request/initiator=] is
        "`prefetch`" or "`preload`", return a [=network error=].

        Note: This ensures that prefetching a signed exchange from one origin
        won't accidentally do a network request from another origin, which could
        [compromise the user's
        privacy](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#private-prefetch).

Note: Applying the signed exchange's response here has the effect of letting a
newer HTTP cache entry override a signed exchange's content, and of not storing
the signed exchange's response in the HTTP cache.

<h2 id="data-types" oldids="structs">Data Types</h2>

<h3 dfn-type=dfn export>Bundle</h3>

A bundle is a [=struct=] with the following items:

<ul dfn-for="bundle">

* <dfn export>manifest</dfn>, a {{webappmanifest}}.
* <dfn export>exchanges</dfn>, a [=map=] whose keys are [=URLs=] and whose
    values are either [=promised responses=] or [=Variant-negotiated response
    maps=].

</ul>

<h3 dfn-type=dfn export>Variant-negotiated response map</h3>

A Variant-negotiated response map is a [=struct=] with the following items:

<ul dfn-for="Variant-negotiated response map">

* <dfn export>variants</dfn>, a <a http-header>Variants</a> value
* <dfn export>responses</dfn>, a [=map=] from <a http-header>Variant-Key</a>
    values to [=promised responses=].

</ul>

<div class="note">

  The bundle's [=bundle/index section=] maps request URLs to arrays holding a <a
  http-header>Variants</a> header [=field-value=] followed by offsets into the
  response data. For example, it might map
  `https://publisher.example/index.html` to «`` `Accept-Encoding;gzip;br,
  Accept-Language;en;fr` ``, 100, 700, 300, 500».

  This example would lead to a Variant-negotiated response map of

  1. «`` `gzip;en` ``» → |promise1|
  2. «`` `gzip;fr` ``» → |promise2|
  3. «`` `br;en` ``» → |promise3|
  4. «`` `br;fr` ``» → |promise4|

  With all promises initially pending. Once enough of the bundle has been
  received to parse a response header starting from offset 100, |promise1| is
  fulfilled with a [=response=] whose [=response/body=] continues to stream in
  as more of the bundle is received. This is followed by |promise3|, |promise4|,
  and |promise2|.

</div>

<h3 dfn-type=dfn export>Promised response</h3>

A promised response is a {{Promise}} containing a [=response=].

<h3 dfn-type=dfn export>Exchange</h3>

An exchange is a [=struct=] with the following items:

<ul dfn-for="exchange">

* <dfn export>request URL</dfn>, a [=URL=].
* <dfn export>response</dfn>, a [=response=].

</ul>

<h3 dfn-type=dfn>Read buffer</h3>

A read buffer is a [=struct=] with the following items:

<ul dfn-for="read buffer">

* <dfn>stream</dfn>: A {{ReadableStream}}.
* <dfn>reader</dfn>: A {{ReadableStreamDefaultReader}} whose stream is [=read
    buffer/stream=].
* <dfn>bytes</dfn>: A [=byte sequence=] holding the bytes that have been read
    from [=read buffer/stream=] but not returned to a calling algorithm yet.

</ul>

<h3 dfn-type=dfn>Augmented Certificate</h3>

An augmented certificate is a [=tuple=] with the following items:

<ol dfn-for="augmented certificate">

1. <dfn>certificate</dfn>, a [=byte sequence=] that's expected to hold a
    DER-encoded X.509v3 certificate ([[RFC5280]]).
1. <dfn>OCSP response</dfn>, a [=byte sequence=] that's expected to hold a
    DER-encoded [=OCSPResponse=] for the [=augmented certificate/certificate=].
1. <dfn>SCT</dfn>, a [=byte sequence=] that's expected to hold a
    [=SignedCertificateTimestampList=] for the [=augmented
    certificate/certificate=].

</ol>

These fields are [=byte sequences=] instead of parsed and validated structures
because we expect some UAs to pass them to other systems for validation, and
some of those systems expect plain byte sequences.

A [=augmented certificate/certificate=] contains a <dfn for="certificate">public
key</dfn> ([=Subject Public Key Info=]), which has an <dfn for="public
key">algorithm</dfn> ([=AlgorithmIdentifier=]).

A [=augmented certificate/certificate=] contains an <dfn
for="certificate">extensions</dfn> map ([=Certificate Extensions=]) from OIDs to
[=byte sequences=].

A <dfn>certificate chain</dfn> is a [=list=] of [=augmented certificates=], of
which the first [=list/item=] is the <dfn for="certificate chain">leaf</dfn>.

<h3 dfn-type=dfn export>Signed Exchange report</h3>

A signed exchange report is a [=struct=] with the following items:

<dl dfn-for="signed exchange report">
: <dfn>result</dfn>
:: The result string of loading signed exchange. This must be unset or one of
    "<dfn>`ok`</dfn>", "<dfn>`mi_error`</dfn>",
    "<dfn>`non_secure_distributor`</dfn>", "<dfn>`parse_error`</dfn>",
    "<dfn>`invalid_integrity_header`</dfn>",
    "<dfn>`signature_verification_error`</dfn>",
    "<dfn>`cert_verification_error`</dfn>", "<dfn>`cert_fetch_error`</dfn>",
    "<dfn>`cert_parse_error`</dfn>",
: <dfn>outer request</dfn>
:: The [=request=] which the user agent sent to the server to load the signed exchange.
: <dfn>outer response</dfn>
:: The [=response=] which the user agent received from the server.
: <dfn>inner URL</dfn>
:: The logical [=URL=] of the signed exchange, if available. Otherwise, an empty
    string.
: <dfn>cert URL list</dfn>
:: The list of [=URLs=] in "`cert-url`" parameters for the signed exchange's
    signatures, if available. Otherwise, an empty list.
: <dfn>server IP</dfn>
:: The IP address of the server from which the user agent received the signed
    exchange, if available. Otherwise, an empty string.
: <dfn>cert server IP list</dfn>
:: The list of IP addresses of the servers from which the user agent received
    the certificates listed in [=signed exchange report/cert URL list=].

</dl>

<h3 dfn-type=dfn export>Bundle report</h3>

A bundle report is a [=struct=] with the following items:

<dl dfn-for="bundle report">
: <dfn>result</dfn>
:: The result string of loading a bundle. This must be unset or one of
    "<dfn>`ok`</dfn>", "<dfn>`mi_error`</dfn>",
    "<dfn>`non_secure_distributor`</dfn>", "<dfn>`parse_error`</dfn>",
    "<dfn>`invalid_integrity_header`</dfn>",
    "<dfn>`signature_verification_error`</dfn>",
    "<dfn>`version_error`</dfn>",
    "<dfn>`cert_verification_error`</dfn>", "<dfn>`cert_fetch_error`</dfn>",
    "<dfn>`cert_parse_error`</dfn>",
: <dfn>outer request</dfn>
:: The [=request=] which the user agent sent to the server to load the bundle.
: <dfn>outer response</dfn>
:: The [=response=] which the user agent received from the server.
: <dfn>inner URL</dfn>
:: The bundle's [=bundle/manifest=]'s {{WebAppManifest/start_url}}, if
    available. Otherwise, an empty string.
: <dfn>server IP</dfn>
:: The IP address of the server from which the user agent received the bundle,
    if available. Otherwise, an empty string.

</dl>

<h3 dfn-type=dfn export>Exchange Signature</h3>

An exchange signature is a [=struct=] with the following items:

<dl dfn-for="exchange signature">
: <dfn>signature</dfn>
:: A [=byte sequence=] holding a signature of the exchange.
: <dfn>certificate chain</dfn>
:: A [=certificate chain=] whose [=certificate chain/leaf=]'s
    [=certificate/public key=] can verify the [=exchange signature/signature=]
    and from which the UA will try to build a path from the [=certificate
    chain/leaf=] to a trusted root.
: <dfn>certSha256</dfn>
:: A [=byte sequence=] holding the [=SHA-256=] hash that verified the [=exchange
    signature/certificate chain=]'s [=certificate chain/leaf=].
: <dfn>integrity header</dfn>
:: A [=list=] of [=ASCII strings=] that describes the response header and any of
    its parameters that guard the integrity of the response payload.
: <dfn>validityUrl</dfn>
:: A [=URL=] describing where to update this signature.
: <dfn>validityUrlBytes</dfn>
:: The bytes that [=exchange signature/validityUrl=] was parsed from.
: <dfn>date</dfn>
:: The POSIX time at which the signature starts being valid.
: <dfn>expiration time</dfn>
:: The POSIX time at which the signature stops being valid.

</dl>

<h3 dfn-type=dfn>Error</h3>

An error is a [=struct=] with the following items:

<dl dfn-for="error">

: <dfn>name</dfn>

:: A name for the error, suitable to be prefixed with "sxg." and used as a
    [=network error's=] [=network error/type=]. One of:

    * <dfn>"unsupported_version"</dfn>
    * <dfn>"untrusted_cert"</dfn>
    * ...

: <dfn>fallback URL</dfn>

:: Null or a [=URL=] that the UA should redirect to in order to recover from the
    error. This is only set for [=error/name|error names=] of [=error/"unsupported_version"=] and [=error/"untrusted_cert"=].

</dl>

<pre class=include>
path: loading-sxg.bs
</pre>

<pre class=include>
path: loading-bundle.bs
</pre>

# Common Algorithms # {#common-algorithms}

## Stream algorithms ## {#stream-algs}

Issue(whatwg/fetch#730): The algorithms in this section create and operate over
ECMAScript objects like {{ReadableStream}} despite not having a Realm to attach
them to.

<h4 algorithm id="create-read-buffer">Create a read buffer</h4>

A <dfn>new read buffer</dfn> for a {{ReadableStream}} |stream| is a new [=read
buffer=] struct whose items are:

: [=read buffer/stream=]
:: |stream|
: [=read buffer/reader=]
:: The result of [=ReadableStream/get a reader|getting a reader=] from
    |stream|.
: [=read buffer/bytes=]
:: An empty [=byte sequence=].

<h4 algorithm id="read-up-to-bytes">Read up to bytes</h4>

To <dfn for="read buffer" lt="reading up to">read up to</dfn> |N| bytes from a
[=read buffer=] |buffer|, the UA MUST:

1. Assert: This algorithm is running [=in parallel=].
1. Let |done| be `false`.
1. While |done| is `false` and the length of |buffer|'s [=read buffer/bytes=]
    item is less than |N| bytes:

    1. Let |chunk| be the result of [=ReadableStream/read a chunk|reading a
        chunk=] with |buffer|'s [=read buffer/reader=].

    1. Wait for |chunk| to settle.

    1. If |chunk| is :

        <dl class="switch">

        : Fulfilled with an object whose `done` property is `false` and whose
            `value` property is a {{Uint8Array}} object:

        ::
            1. Let |bs| be the [=byte sequence=] represented by the
                {{Uint8Array}} object.
            1. Set |buffer| to the concatenation of |buffer| and |bs|.

        : Fulfilled with an object whose `done` property is `true`:
        :: Set |done| to `true`.

        : Rejected with |e|:
        :: Return a failure with reason |e|.

        </dl>

1. If |buffer|'s [=read buffer/bytes=] item is at least |N| bytes long:
    1. Let |result| be a [=byte sequence=] consisting of the first N bytes of
        |buffer|'s [=read buffer/bytes=] item.
    1. Set |buffer|'s [=read buffer/bytes=] item to a [=byte sequence=]
        consisting of the bytes after the |N|th from its old value.
1. Otherwise:
    1. Let |result| be |buffer|'s [=read buffer/bytes=] item.
    1. Set |buffer|'s [=read buffer/bytes=] item to an empty [=byte sequence=].

1. Return |result|.


<h4 algorithm id="read-bytes">Read bytes</h4>

To <dfn for="read buffer">read</dfn> |N| bytes from a [=read buffer=] |buffer|,
the UA MUST:

1. Assert: This algorithm is running [=in parallel=].
1. Let |bytes| be the result of [=read buffer/reading up to=] |N| bytes from
    |buffer|.
1. If |bytes| is a failure, return it.
1. If |bytes| is exactly |N| bytes long, return it.
1. Otherwise, return a failure.

<h4 algorithm id="dump-stream">Dump to another stream</h4>

To <dfn for="read buffer">Dump</dfn> a [=read buffer=] |input| to a
{{ReadableStream}} |output|, the UA MUST:

1. Assert: This algorithm is running [=in parallel=].
1. Let |enqueue| be the following steps, taking |bytes|:
    1. [=ReadableStream/Enqueue=] a {{Uint8Array}} object wrapping an
        {{ArrayBuffer}} containing |bytes| to |output|. Both objects are created
        in |output|'s realm.
    1. If that threw an exception |ex|, [=ReadableStream/error=] |output| with
        |ex| and [=ReadableStream/cancel=] |input|'s [=read buffer/stream=] with
        |ex|.
    1. Abort this algorithm.
1. |enqueue| |input|'s [=read buffer/bytes=].
1. While |input|'s [=read buffer/stream=] is [=ReadableStream/readable=]:
    1. Wait until |output| is [=ReadableStream/closed=],
        [=ReadableStream/errored=], or [=ReadableStream/need more data|needs
        more data=].
    1. If |output| is [=ReadableStream/closed=] or [=ReadableStream/errored=],
        [=ReadableStream/cancel=] |input|'s [=read buffer/stream=] and abort
        these steps.
    1. Let |chunk| be the result of [=ReadableStream/read a chunk|reading a
        chunk=] with |input|'s [=read buffer/reader=].
    1. Wait for |chunk| to settle.
    1. If |chunk| is:

        <dl class="switch">

        : Fulfilled with an object whose `done` property is `false` and whose
            `value` property is a {{Uint8Array}} object |bytes|:
        :: |enqueue| |bytes|.

        : Fulfilled with an object whose `done` property is `true`:
        :: [=ReadableStream/Close=] |output|.

        : Rejected with |e|:
        :: [=ReadableStream/Error=] |output| with reason |e|.

        </dl>

# Security Considerations # {#seccons}

The Security Considerations of [[draft-yasskin-http-origin-signed-responses]]
apply.

## Certificate Transparency ## {#seccons-ct}

To identify [=off-path attackers=], [[#trusting-certificate]] encourages UAs to
implement Certificate Transparency, which requires that, in order for a
certificate to be trusted, it must be logged publicly. This means that an
off-path attacker who has managed to get a mis-issued certificate has to at
least announce that certificate in a place the legitimate domain owner has a
chance to notice. Once they notice, they can revoke the certificate, which will
stop the UA from trusting it no more than 7 days later.
